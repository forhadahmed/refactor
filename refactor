#!/usr/bin/env python3
import io, os, sys, time, json, argparse, subprocess
from collections import defaultdict

from difflib import SequenceMatcher as SM
from difflib import ndiff as ndiff

#------------------------------------------------------------------------------

parser = argparse.ArgumentParser()

input_group = parser.add_argument_group('Input')
input_group.add_argument('-f', action='store_true', help='Filter stdin file list by known extensions.')
input_group.add_argument('--python', action='store_true', help='Force Python parser for all files.')

parse_group = parser.add_argument_group('Parsing')
parse_group.add_argument('-b', action='store_true', help='Print parsed blocks and exit.')
parse_group.add_argument('-d', action='store_true', help='Debug output (parser state, traces, verbose errors).')
parse_group.add_argument('--tree', action='store_true', help='Print the block tree.')
parse_group.add_argument('--stats', action='store_true', help='Print block statistics.')

compare_group = parser.add_argument_group('Comparison')
compare_group.add_argument('--similarity', default=0.8, type=float, help='Similarity threshold (SequenceMatcher ratio).')
compare_group.add_argument('--min-block-size', default=1500, type=int, help='Minimum block size in chars.')
compare_group.add_argument('--max-block-diff', default=500, type=int, help='Max block size difference in chars.')
compare_group.add_argument('--all-indents', action='store_true', help='Compare blocks across indent levels.')
compare_group.add_argument('--all-files', action='store_true', help='Compare blocks across all files.')
compare_group.add_argument('--all', action='store_true', help='--all-indents and --all-files.')
compare_group.add_argument('--shingle-k', default=7, type=int, help=argparse.SUPPRESS)
compare_group.add_argument('--no-shingle', action='store_true', help=argparse.SUPPRESS)
compare_group.add_argument('--show-pairs', action='store_true', help=argparse.SUPPRESS)

output_group = parser.add_argument_group('Output')
output_group.add_argument('-o', '--output', help='Output file for HTML report.')
output_group.add_argument('--diff-width', default=180, type=int, help='Diff width for terminal/HTML output.')
output_group.add_argument('--html', action='store_true', help='Write HTML report.')
output_group.add_argument('--json', action='store_true', help='Write JSON output.')
output_group.add_argument('--no-cleanup', action='store_true', help='Keep temporary HTML files.')
output_group.add_argument('--timing', action='store_true', help='Print timing breakdown.')

args, inputs = parser.parse_known_args()

# expand combined flags
if args.all:
   args.all_indents = True
   args.all_files = True

filters = 'c,cpp,h,hh,hpp,py,go,rs,java,js,swift,php'

if not inputs:
   inputs = sys.stdin.read().split('\n')
   filters = [ f.strip() for f in filters.split(',') ]
   filters = ['.%s' % f for f in filters]
   if args.f:
      inputs = [ f for f in inputs if
           any([ f.endswith(e) for e in filters ])
      ]
   #end
#end

#------------------------------------------------------------------------------
#
#  Misc
#
#------------------------------------------------------------------------------

def spinning_cursor():
    while True:
      for cursor in ['[|]','[/]','[-]','[\\]']:
        yield cursor

spinner = spinning_cursor()
mlen = 0
sidx = 0
cols = 0
tty = 0

if sys.stdout.isatty():
   cols = os.get_terminal_size().columns-1
   tty = 1
#end

def prints(s, rate=1, force=0):
    if not tty: return
    global mlen, sidx
    sidx += 1
    if not (sidx % rate) or force:
       s = ( next(spinner) + ' ' + s )
       if len(s) > cols: s = s[:cols-4] + '...'
       sys.stdout.write(s + ' ' * (cols - len(s)) + '\r')
       sys.stdout.flush()

# clear spinner line before output
def printc():
    if tty and sidx > 0:
       sys.stdout.write(' ' * cols + '\r')
       sys.stdout.flush()

#------------------------------------------------------------------------------
#
#  Parsing
#
#------------------------------------------------------------------------------

class block:
   def __init__(self, file, line, indent, parent):
       self.file = file
       self.size = 0
       self.range = [line,-1]
       self.indent = indent
       self.parent = parent
       self.codebuf = []
       self.code = ""
       self.children = []
       if self.parent: parent.children.append(self)
   #end

   def add_code(self, c):
       self.codebuf.append(c)
       if self.parent: self.parent.add_code(c)
   #end

   def finalize(self):
       self.code = ''.join(self.codebuf)
       self.codebuf = []
   #end

   # compute k-character shingle hashes for fast similarity pre-filter
   def compute_shingles(self, k=7):
       if len(self.code) < k:
          self.shingles = frozenset()
       else:
          self.shingles = frozenset(
             hash(self.code[i:i+k]) for i in range(len(self.code) - k + 1)
          )
   #end
#end

# jaccard similarity of two sets
def jaccard(s1, s2):
    if not s1 or not s2: return 0
    return len(s1 & s2) / len(s1 | s2)
#end

def is_python_file(fn):
    if fn.endswith('.py'): return True
    try:
       with open(fn, 'rb') as f: first = f.readline(200)
    except:
       return False
    if not first.startswith(b'#!'): return False
    return (b'python' in first)
#end

#-- Python --------------------------------------------------------------------

def process_py(fn, line, ln, indent):

    global stack, blocks

    if args.d:
       print(fn, '%5d' % ln, '%2d' % indent, end='')
       print(' [%s]' % ('.' * len(stack)), line, end='')
    #end

    top = stack[-1]

    if not line.rstrip() or line[indent] in ['#','"',"'"]:
       top.add_code(line)
       return
    #end

    if indent == top.indent: top.add_code(line)

    if indent > top.indent:
       b = block(fn, ln, indent, top)
       b.add_code(line)
       stack.append(b)
       blocks.append(b)
    #end

    if indent < top.indent:
       while len(stack) > 1:
          b = stack.pop()
          b.range[1] = ln
          top = stack[-1]
          if indent >= top.indent: break
       #end
       top.add_code(line)
    #end

#end

def process_pfile(fn, f):

    global state, ln

    b = block(fn, 1, 0, None)
    stack.append(b)
    blocks.append(b)

    prints(fn)

    mlstr = 0 # multiline string state: 0=none, 1=""", 2='''
    mlstr_start = 0

    for ln, line in enumerate(f):
        ln = ln+1

        # skip multiline string detection in comments
        stripped = line.lstrip()
        is_comment = stripped.startswith('#')

        # check for multiline string start/end
        if mlstr:
           if mlstr == 1 and '"""' in line:
              if args.d: print('MLSTR """ EXIT  %s:%d (%d lines)' % (fn, ln, ln - mlstr_start))
              mlstr = 0
           if mlstr == 2 and "'''" in line:
              if args.d: print("MLSTR ''' EXIT  %s:%d (%d lines)" % (fn, ln, ln - mlstr_start))
              mlstr = 0
           stack[-1].add_code(line)
           continue
        if not is_comment and '"""' in line and line.count('"""') == 1:
           mlstr = 1; mlstr_start = ln
           if args.d: print('MLSTR """ ENTER %s:%d' % (fn, ln))
        elif not is_comment and "'''" in line and line.count("'''") == 1:
           mlstr = 2; mlstr_start = ln
           if args.d: print("MLSTR ''' ENTER %s:%d" % (fn, ln))

        indent = 0
        for ch in line:
            if ch.isspace(): indent += 1
            else: break
        process_py(fn, line, ln, indent)
    #end

#end

#-- C/C++ (curly bracket languages) -------------------------------------------

code     = 0 # normal code
macro    = 1 # #define ...
string1  = 2 # "abc"
string2  = 3 # 'd'
comment1 = 4 # // comment
comment2 = 5 # /* comment */

state_names = ['code','macro','string1','string2','comment1','comment2']

state  = code

# timing
tparse = 0
tfilter = 0
tcompare = 0
toutput = 0

# state trace history for verbose errors
state_history = []
indent = 0
stack  = []
blocks = []

def process_ch(fn, ch, ln):

    global state, indent, stack, blocks

    if args.d:
       print(fn, '%5d' % ln, state, end='')
       print('  ' if ch.isspace() else ' %s' % ch, end='')
       print(' [%s]' % ('*' * len(stack)))
    #end

    top = stack[-1] if stack else None
    # start of block
    if ch == '{' and state == code:
       indent += 1
       b = block(fn, ln, indent, top)
       stack.append(b)
       blocks.append(b)
    #end

    # end of block
    if ch == '}' and state == code:
       indent -= 1
       if not stack:
          print('[!] %s:%d' % (fn, ln)) # error
          return False
       b = stack.pop()
       b.range[1] = ln
       top = stack[-1] if stack else 0
    #end

    if top: top.add_code(ch)

    return True;

#end

def process_cfile(fn, f):

    global state, ln, state_history

    pch = 0; esc = 0
    state_history = []

    content = f.read()
    L = len(content)
    i = 0

    while i < L:
      ch = content[i]
      i += 1
      if ch == '\n': ln += 1

      pstate = state

      if state == code:
         if ch == '#': state = macro
         if ch == '"': state = string1
         if ch == "'": state = string2
         if ch == '/' and i < L:
            if not process_ch(fn, ch, ln): break
            ch = content[i]
            i += 1
            if ch == '\n': ln += 1
            if ch == '/': state = comment1
            if ch == '*': state = comment2

      elif state == string1:
         if ch == '"' and not esc: state = code

      elif state == string2:
         if ch == "'" and not esc: state = code

      elif state == comment1:
         if ch == '\n': state = code

      elif state == macro:
         if ch == '\n' and pch != '\\': state = code

      elif state == comment2:
         if ch == '/' and pch == '*': state = code
      #end

      if state != pstate and args.d:
         tr = '%s -> %s' % (state_names[pstate], state_names[state])
         print('TRACE %s:%d %s (ch=%s)' % (fn, ln, tr, repr(ch)))
      if state != pstate and args.d:
         state_history.append((ln, pstate, state, ch))
         if len(state_history) > 5: state_history.pop(0)

      if not process_ch(fn, ch, ln): break

      esc = (ch == '\\' and not esc)
      pch = ch

    #end

    if not indent and not stack: return
    print('[!] %s:%d' % (fn, ln)) # error
    if not args.d: return
    print('    indent=%d stack_depth=%d state=%s' % (indent, len(stack), state_names[state]))
    if state_history:
       print('    last state changes:')
       for h in state_history:
          print('      L%d: %s -> %s (ch=%s)' % (h[0], state_names[h[1]], state_names[h[2]], repr(h[3])))
       #end
    #end
    if stack:
       print('    stack: %s' % ', '.join(['L%d' % b.range[0] for b in stack]))
    #end

#end

#------------------------------------------------------------------------------
#
#  Main
#
#------------------------------------------------------------------------------

nfiles = 0
t0 = time.time()

for fn in inputs:

   ln = 1
   state = code
   stack = []
   indent = 0
   mlen = max(len(fn), mlen)

   if not os.path.isfile(fn): continue

   nfiles += 1

   try:

      prints(fn)

      use_python = (args.python or is_python_file(fn))
      if use_python:
         with open(fn) as f: process_pfile(fn, f)
      else:
         with open(fn) as f: process_cfile(fn, f)
      #end

   except KeyboardInterrupt:
      sys.exit(1)
   except UnicodeDecodeError:
      pass

#end

tparse = time.time() - t0

# finalize all blocks (join code buffers)
for b in blocks: b.finalize()

# compute shingles for similarity pre-filter
for b in blocks: b.compute_shingles(args.shingle_k)

all_blocks = list(blocks)

# filter out small blocks
t0 = time.time()
nraw = len(blocks)
blocks = [ b for b in blocks if len(b.code) > args.min_block_size ]
for b in blocks: b.size = len(b.code)
tfilter = time.time() - t0

#
# stats output
#
if args.stats:
   printc()
   sizes = [len(b.code) for b in blocks]
   indents = {}
   for b in blocks: indents[b.indent] = indents.get(b.indent, 0) + 1
   largest = max(blocks, key=lambda x: len(x.code)) if blocks else None
   print('--- Statistics ---')
   print('Files processed:  %d' % nfiles)
   print('Total blocks:     %d' % nraw)
   print('After filtering:  %d (min=%d chars)' % (len(blocks), args.min_block_size))
   if sizes:
      print('Avg block size:   %d chars' % (sum(sizes) // len(sizes)))
      print('Largest block:    %s:%d (%d chars)' % (largest.file, largest.range[0], len(largest.code)))
   #end
   istr = ', '.join(['L%d=%d' % (k, indents[k]) for k in sorted(indents.keys())])
   print('Blocks by indent: %s' % istr)
   sys.exit(0)
#end

#
# tree output
#
def print_tree(b, prefix=''):
   rng = '%d-%d' % (b.range[0], b.range[1]) if b.range[1] > 0 else '%d-?' % b.range[0]
   print('%s%s:%s (%d chars)' % (prefix, b.file if not prefix else '', rng, len(b.code)))
   for i, ch in enumerate(b.children):
      is_last = (i == len(b.children) - 1)
      print_tree(ch, prefix + ('    ' if is_last else '|   '))
   #end
#end

if args.tree:
   printc()
   print('--- Block Tree ---')
   roots = [b for b in all_blocks if b.parent is None or b.parent not in all_blocks]
   for r in roots: print_tree(r)
   sys.exit(0)
#end

#
# debugging
#
if args.b:
   printc()
   print(len(all_blocks), 'blocks')
   for b in all_blocks:
          hlen = len(b.file)+30
          print('-'*hlen)
          print('%s:%d - %d'%(b.file,b.range[0],b.indent))
          print('-'*hlen)
          for line in b.code: print(line,end="")
          print()
      #end
   #end
   sys.exit(0)
#end

#------------------------------------------------------------------------------
#
#  Processing
#
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Pre-compute file relationships
#------------------------------------------------------------------------------

fcache = {}
files = list(set(b.file for b in blocks))
for i, f1 in enumerate(files):
    for f2 in files[i:]:
        if f1 == f2:
            fcache[(f1, f2)] = True
        else:
            related = SM(None, f1, f2).ratio() >= 0.9
            fcache[(f1, f2)] = related
            fcache[(f2, f1)] = related
#end

def files_related(f1, f2):
    if args.all_files: return True
    return fcache.get((f1, f2), False)
#end

# check if b is ancestor of a
def is_ancestor(a, b):
    p = a.parent
    visited = set()
    while p:
       if id(p) in visited: return False
       visited.add(id(p))
       if b == p: return True
       p = p.parent
    return False
#end

# check if block is descendant of any block in matched_ids
def is_descendant_of_any(block, matched_ids):
    p = block.parent
    while p:
       if id(p) in matched_ids: return True
       p = p.parent
    return False
#end

#------------------------------------------------------------------------------
# Pre-partition by indent level
#------------------------------------------------------------------------------

if args.all_indents:
    indent_groups = {0: blocks}
else:
    indent_groups = defaultdict(list)
    for b in blocks:
        indent_groups[b.indent].append(b)
#end

#------------------------------------------------------------------------------
# Generate candidate pairs (with cheap filters)
#------------------------------------------------------------------------------

# generate (bi, bj) pairs passing cheap filters
def generate_pairs(blist):
    sorted_list = sorted(blist, key=lambda x: -x.size)
    L = len(sorted_list)
    pairs = []
    for i in range(L):
        bi = sorted_list[i]
        for j in range(i+1, L):
            bj = sorted_list[j]
            # size window check
            if bi.size - bj.size > args.max_block_diff: break
            # file relationship check
            if not files_related(bi.file, bj.file): continue
            # ancestor check
            if is_ancestor(bi, bj) or is_ancestor(bj, bi): continue
            # shingle pre-filter (jaccard > 0.3 as loose pre-filter)
            if not args.no_shingle and jaccard(bi.shingles, bj.shingles) < 0.3: continue
            pairs.append((bi, bj))
    return pairs
#end

# compare a single pair - returns (bi, bj, ratio) or None
def compare_pair(pair):
    bi, bj = pair
    sm = SM(None, bi.code, bj.code)
    if sm.quick_ratio() < args.similarity: return None
    ratio = sm.ratio()
    if ratio < args.similarity: return None
    return (bi, bj, ratio)
#end

#------------------------------------------------------------------------------
# Main comparison loop
#------------------------------------------------------------------------------

all_matches = []
t0 = time.time()

# --show-pairs: count candidate pairs and exit
if args.show_pairs:
    printc()
    total_pairs = 0
    potential_pairs = 0
    for indent, blist in indent_groups.items():
        n = len(blist)
        potential_pairs += n * (n - 1) // 2
        pairs = generate_pairs(blist)
        total_pairs += len(pairs)
        print('indent %d: %d blocks -> %d candidate pairs' % (indent, n, len(pairs)))
    print('---')
    print('Total blocks: %d' % len(blocks))
    print('Potential pairs (B²/2): %d' % potential_pairs)
    print('After shingle filter: %d (%.2f%%)' % (total_pairs, 100*total_pairs/potential_pairs if potential_pairs else 0))
    sys.exit(0)
#end

for indent, blist in indent_groups.items():
    prints('indent level %d: %d blocks' % (indent, len(blist)), rate=1)

    pairs = generate_pairs(blist)
    if args.timing: print('  indent %d: %d candidate pairs' % (indent, len(pairs)))
    if not pairs: continue

    matches = []
    for idx, pair in enumerate(pairs):
        if idx % 100 == 0: prints('comparing %d/%d' % (idx, len(pairs)), rate=1)
        result = compare_pair(pair)
        if result: matches.append(result)
    #end

    all_matches.extend(matches)
#end

# Phase 3: Filter redundant child matches (globally across all indent levels)
all_matches.sort(key=lambda x: -max(x[0].size, x[1].size))
matched_ids = set()
similar = []

for bi, bj, ratio in all_matches:
    if is_descendant_of_any(bi, matched_ids): continue
    if is_descendant_of_any(bj, matched_ids): continue
    # save match (smaller block first)
    if bj.size > bi.size:
        similar.append((bi, bj, ratio))
    else:
        similar.append((bj, bi, ratio))
    matched_ids.add(id(bi))
    matched_ids.add(id(bj))
#end

tcompare = time.time() - t0

# sort deterministically: by first file, then first line, then second file, then second line
similar = sorted(similar, key=lambda x: (x[0].file, x[0].range[0], x[1].file, x[1].range[0]))

#------------------------------------------------------------------------------
#
#  Terminal formatting helpers
#
#------------------------------------------------------------------------------

# ANSI color codes
TRED = '\033[41m'  # red background
TGRN = '\033[42m'  # green background
TBLD = '\033[1m'   # bold
TRST = '\033[0m'   # reset
TGRY = '\033[90m'  # gray text
TYEL = '\033[33m'  # yellow text
TDIV = ' │ '       # vertical divider
TDIVY = ' ' + TYEL + '│' + TRST + ' '  # yellow divider for differences

def chardiff(s1, s2, half):
    # character-by-character diff using ndiff
    S1 = ''; S2 = ''; len1 = 0; len2 = 0
    for d in ndiff(s1, s2):
        op, ch = d[0], d[2]
        if op == ' ':
            S1 += ch; S2 += ch; len1 += 1; len2 += 1
        elif op == '-':
            S1 += TRED + ch + TRST; len1 += 1
        elif op == '+':
            S2 += TGRN + ch + TRST; len2 += 1
        #end
    #end
    # pad to half width
    if len1 < half: S1 += ' ' * (half - len1)
    if len2 < half: S2 += ' ' * (half - len2)
    return S1, S2
#end

def diff2term(bi, bj, width):
    out = ''
    middle = width // 2
    half = middle - 2

    # header
    H1 = ' %s:%d ' % (bi.file, bi.range[0])
    H2 = ' %s:%d ' % (bj.file, bj.range[0])
    hdr = TBLD + H1.ljust(half) + ' │ ' + H2.ljust(half) + TRST
    out += '\n' + '-' * width + '\n'
    out += hdr + '\n'
    out += '-' * width + '\n'

    # get lines from both blocks
    lines1 = bi.code.splitlines()
    lines2 = bj.code.splitlines()

    # line-by-line diff
    sm = SM(None, lines1, lines2)

    for op, i1, i2, j1, j2 in sm.get_opcodes():
        if op == 'equal':
            for k in range(i2 - i1):
                L1 = lines1[i1 + k][:half].ljust(half)
                L2 = lines2[j1 + k][:half].ljust(half)
                out += L1 + TDIV + L2 + '\n'
            #end
        elif op == 'replace':
            maxlen = max(i2 - i1, j2 - j1)
            for k in range(maxlen):
                s1 = lines1[i1 + k][:half] if i1 + k < i2 else ''
                s2 = lines2[j1 + k][:half] if j1 + k < j2 else ''
                L1, L2 = chardiff(s1, s2, half)
                out += L1 + TDIVY + L2 + '\n'
            #end
        elif op == 'delete':
            for k in range(i2 - i1):
                L1 = TRED + lines1[i1 + k][:half].ljust(half) + TRST
                out += L1 + TDIVY + ' ' * half + '\n'
            #end
        elif op == 'insert':
            for k in range(j2 - j1):
                L2 = TGRN + lines2[j1 + k][:half].ljust(half) + TRST
                out += ' ' * half + TDIVY + L2 + '\n'
            #end
        #end
    #end

    return out
#end

#------------------------------------------------------------------------------
#
#  HTML formatting helpers
#
#------------------------------------------------------------------------------

VSP = '&#9474' # vertical separator
GRN = '<span style="background:#ccffcc">'
RED = '<span style="background:#ffcccc">'
GRY = '<span style="color:#cccccc">'
YEL = '<span style="color:#ffd480">'
ESP = '</span>'

def esc(s): return s.replace('<', '&lt;')

def diff2html(df, bi, bj, index):

    html = ""
    width = args.diff_width
    middle = int(width/2)

    DIV  = GRY + VSP + ESP
    DIV2 = YEL + VSP + ESP
 
    # section links
    html += '<pre style="background:white;caret-color:transparent;'
    html += 'border:none;text-align:center">\n'
    html += '<span id="%s" style="">' % index
    html += ' <a href="#%s">next</a>' % (index + 1)
    if index != 1000:
       html += ' <a href="#%s">prev</a>' % (index - 1)
       html += ' <a href="#%s">up</a>' % 1000
    #end
    html += '</span>'
    html += ' ' * (width - (4 if index == 1000 else 12))
    html += '</pre>'

    # section file headers
    html += '<pre style='
    html += '"background:white;caret-color:transparent;'
    html += 'border:none;text-align:center">'
    html += '<span style="border:1px #ccc solid;'
    html += 'border-radius:3px;padding:5px;font-weight:bold">'
    H1 = ' %s:%d' % (bi.file, bi.range[0])
    H2 = ' %s:%d' % (bj.file, bj.range[0])
    html += ( H1 + ' '*((middle-1)-len(H1)))
    html += VSP
    html += ( H2 + ' '*(middle-len(H2)) )
    html += '</span></pre>\n'

    # diff
    html += '<pre style='
    html += '"background:white;caret-color:transparent;'
    html += 'border:none;text-align:center">\n'

    for line in df:

        line = line[:-1]
        line += ' '*(width-len(line))

        dm = line[middle-1]
        L1 = line[:middle-1]
        L2 = line[middle:]

        if dm == ' ':
           html += "%s%s%s\n" % (esc(L1), DIV, esc(L2))
           continue
        if dm == '<':
           html += '%s%s%s%s%s\n' % (RED, esc(L1), ESP, DIV, esc(L2))
           continue
        if dm == '>':
           html += '%s%s%s%s%s\n' % (esc(L1), DIV, GRN, esc(L2), ESP)
           continue
        if dm == '|':
           S1 = ''; S2 = ''
           for i in ndiff(L1, L2):
              ch = esc(i[2])
              if i[0] == ' ': S1 += ch; S2 += ch
              if i[0] == '+': S2 += ch if ch.isspace() else GRN + ch + ESP
              if i[0] == '-': S1 += ch if ch.isspace() else RED + ch + ESP
           #end
           html += '%s%s%s\n' % (S1, DIV2, S2)
        #end

    #end

    html += '</pre>\n'

    return html

#end

#------------------------------------------------------------------------------
#
#  Post processing
#
#------------------------------------------------------------------------------

prints('post processing')

t0 = time.time()

nsimilar = len(similar)
prints('', force=1)
printc()

if not nsimilar and not args.json:
   print(nsimilar, 'similar blocks found')
   if args.timing:
      print('--- Timing ---')
      print('Parsing:    %.2fs (%d files, %.1fms/file)' % (tparse, nfiles, tparse*1000/nfiles if nfiles else 0))
      print('Filtering:  %.2fs (%d -> %d blocks)' % (tfilter, nraw, len(blocks)))
      print('Comparison: %.2fs' % tcompare)
   #end
   sys.exit(0)
#end

#
# json output
#
if args.json:
   output = {
      'version': 1,
      'files_processed': nfiles,
      'blocks_total': nraw,
      'blocks_filtered': len(blocks),
      'min_block_size': args.min_block_size,
      'similarity_threshold': args.similarity,
      'similar_count': nsimilar,
      'pairs': []
   }
   for bi, bj, ratio in similar:
      output['pairs'].append({
         'block1': {
            'file': bi.file,
            'line_start': bi.range[0],
            'line_end': bi.range[1],
            'indent': bi.indent,
            'size': bi.size
         },
         'block2': {
            'file': bj.file,
            'line_start': bj.range[0],
            'line_end': bj.range[1],
            'indent': bj.indent,
            'size': bj.size
         },
         'similarity': round(ratio, 4)
      })
   #end
   print(json.dumps(output, indent=2))
   sys.exit(0)
#end

#
# terminal output (default)
#
if not args.html:
   width = cols if cols else 120
   term_out = '%d similar blocks found\n' % nsimilar
   for bi, bj, _ in similar:
      term_out += diff2term(bi, bj, width)
   #end
   term_out += '\n'
   # pipe to less -R for paging with color support
   if tty:
      pager = subprocess.Popen(['less', '-R'], stdin=subprocess.PIPE)
      pager.communicate(input=term_out.encode())
   else:
      print(term_out, end='')
   #end
#end

#
# html output
#
if args.html:
   print(nsimilar, 'similar blocks found')
   DN = '2>/dev/null'
   root = '/tmp/refactor-%d' % os.getpid()
   os.system('mkdir -p %s/diffs' % root)
   os.system('mkdir -p %s/files' % root)

   def dash(fname): return fname.replace('/', '-')

   index = 1000
   for (bi, bj, _) in similar:
      fstr = '%s/files/%d-%s-%d-%d'
      farg = (root, index, dash(bi.file), bi.range[0], bi.range[1])
      bifn = fstr % farg
      farg = (root, index, dash(bj.file), bj.range[0], bj.range[1])
      bjfn = fstr % farg
      with open(bifn, 'w') as f: f.write(bi.code)
      with open(bjfn, 'w') as f: f.write(bj.code)

      dif = '%s/diffs/%d.diff' % (root, index)
      cmd = 'diff -t -y --width=%d %s %s > %s'
      cmd = cmd % (args.diff_width, bifn, bjfn, dif)
      os.system(cmd)

      htf = dif.replace('.diff', '.html')
      with open(dif, 'r') as f: html = diff2html(f, bi, bj, index)
      with open(htf, 'w') as f: f.write(html)

      index += 1
   #end

   output = ('refactor-%d.html' % os.getpid())
   if args.output: output = args.output

   cmd = 'cat %s/diffs/*.html > %s %s ' % (root, output, DN)
   os.system(cmd)
   print('>', output)

   if not args.no_cleanup: os.system('rm -rf %s' % root)
#end

toutput = time.time() - t0

#
# timing output
#
if args.timing:
   ttotal = tparse + tfilter + tcompare + toutput
   print('--- Timing ---')
   print('Parsing:    %.2fs (%d files, %.1fms/file)' % (tparse, nfiles, tparse*1000/nfiles if nfiles else 0))
   print('Filtering:  %.2fs (%d -> %d blocks)' % (tfilter, nraw, len(blocks)))
   print('Comparison: %.2fs' % tcompare)
   print('Output:     %.2fs' % toutput)
   print('Total:      %.2fs' % ttotal)
#end
