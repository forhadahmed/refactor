#!/usr/bin/env python3
import io, os, sys, time

from difflib import SequenceMatcher as SM
from difflib import ndiff as ndiff

#------------------------------------------------------------------------------

import argparse

parser = argparse.ArgumentParser()
parser.add_argument('--min-block-size', default=1000, type=int)
parser.add_argument('--max-block-diff', default=500, type=int)
parser.add_argument('--similarity', default=0.8, type=float)
parser.add_argument('--diff-width', default=180, type=int)
parser.add_argument('--no-cleanup', action='store_true')
parser.add_argument('--all-levels', action='store_true')
parser.add_argument('--all-files', action='store_true')
parser.add_argument('-d', action='store_true')
parser.add_argument('-o', '--output')


args, inputs = parser.parse_known_args()

if not inputs: inputs = sys.stdin.read().split('\n')

#------------------------------------------------------------------------------
#
#  Misc
#
#------------------------------------------------------------------------------

def spinning_cursor():
    while True:
      for cursor in ['[|]','[/]','[-]','[\\]']:
        yield cursor

spinner = spinning_cursor()
mlen = 0
sidx = 0

def print_spinner(s, rate=30000, force=0):
    global mlen, sidx
    sidx += 1
    if not (sidx % rate) or force:
       sys.stdout.write(next(spinner) + ' ' + s )
       sys.stdout.write(' '*(mlen-len(s)+20) + '\r')
       sys.stdout.flush()

#------------------------------------------------------------------------------
#
#  Parsing
#
#------------------------------------------------------------------------------

code     = 0 # normal code
macro    = 1 # #define ...
string1  = 2 # "abc"
string2  = 3 # 'd'
comment1 = 4 # // comment
comment2 = 5 # /* comment */

state  = code
indent = 0
stack  = []
blocks = []

class block:
   def __init__(self, file, line, indent, parent):
       self.file = file
       self.range = [line,-1]
       self.indent = indent
       self.parent = parent
       self.code = []
       self.children = []
   #end

   def add_code(self, c):
       self.code += [c]
       if self.parent: self.parent.add_code(c)
   #end
#end


def process(file, ch, line):

    global state, indent, stack, blocks

    if args.d:
       print(file, '%5d' % line, state, end='')
       print('  ' if ch.isspace() else ' %s' % ch, end='')
       print('[%s]' % ('*' * len(stack)))
    #end

    top = stack[-1] if stack else None
    # start of block
    if ch == '{' and state == code:
       indent += 1
       b = block(file, line, indent, top)
       if top: top.children.append(b)
       stack.append(b)
       blocks.append(b)
    #end

    # end of block
    if ch == '}' and state == code:
       indent -= 1
       if not stack:
          print('[!] %s:%d' % (file, line)) # error
          return False
       b = stack.pop()
       b.range[1] = line
    #end

    print_spinner(file)

    if top: top.add_code(ch)

    return True;

#end

for fn in inputs:

  line = 1
  state = code
  indent = 0
  mlen = max(len(fn), mlen)

  if not os.path.isfile(fn): continue

  with open(fn) as f:

    ch = 0; pch = 0

    while 1:

      ch = f.read(1)
      if not ch: break
      if ch == '\n': line += 1

      if state == code:
         if ch == '#': state = macro
         if ch == '"': state = string1
         if ch == "'": state = string2
         if ch == '/':
            if not process(fn, ch, line): break

            ch = f.read(1)
            if not ch: break
            if ch == '\n': line += 1

            if ch == '/': state = comment1
            if ch == '*': state = comment2

      elif state == string1:
         if ch == '"': state = code

      elif state == string2:
         if ch == "'": state = code

      elif state == comment1 or state == macro:
         if ch == '\n' and pch != '\\': state = code

      elif state == comment2:
         if ch == '/' and pch == '*': state = code
      #end

      if not process(fn, ch, line): break

      pch = ch

   #end

#end

#------------------------------------------------------------------------------
#
#  Processing
#
#------------------------------------------------------------------------------

# filter out small blocks
blocks = [ b for b in blocks if len(b.code) > args.min_block_size ]

blocks = sorted(blocks, key=lambda x: len(x.code), reverse=True)

groups = {0:[]}

for b in blocks:
    b.code = ''.join(b.code)
    bf = b.file
    groups[0] += [b] # global group
    if bf in groups:
       groups[bf] += [b]
    else:
       groups[bf] = [b]
    #end
#end

skip = []

def skip_children(b):
    global skip
    for ch in b.children:
      if ch in blocks:
        skip += [blocks.index(ch)]
        skip_children(ch)
    #end
#end

def ancestor(a, b):
    p = a.parent
    while p:
       if b == p: return 1
       p = p.parent
    #end
    return 0
#end

fcache = {}

# return true to skip block comparison based on filenames
def skip_unrelated_files(f1, f2):
    if args.all_files: return False
    global fcache
    if (f1,f2) in fcache: return fcache[(f1,f2)]
    if (f2,f1) in fcache: return fcache[(f2,f1)]
    if f1 == f2:
       return False
    else:
       if SM(None, f1, f2).ratio() < 0.9:
          fcache[(f1,f2)] = True
          return True
       else:
          fcache[(f1,f2)] = False
          return False
       #end
    #end
#end

similar = []

keys = {0} # use the global block list for now

for k in keys:

   blks = groups[k]

   L = len(blks)

   for i in range(0, L):

      for j in range(i+1, L):

         print_spinner('comparing blocks %4d - %4d %s' % (i,L,k), rate=500)

         # skip if either block is a child of matched block
         if i in skip or j in skip: continue

         bi = blks[i]; bj = blks[j]

         # skip if filenames are unrelated
         if skip_unrelated_files(bi.file, bj.file): continue

         # skip if one block is a parent of another
         if ancestor(bi, bj) or ancestor(bj, bi): continue

         # skip if the length of code sections differs by a threshold
         if abs(len(bi.code)-len(bj.code)) > args.max_block_diff: continue

         # skip if blocks are not on the same level
         if not args.all_levels and bi.indent != bj.indent: continue

         # do the comparison (skip if blocks are not similar)
         sm = SM(None, bi.code, bj.code)
         if sm.quick_ratio() < args.similarity: continue
         if sm.ratio()       < args.similarity: continue

         # found similar blocks - add their children to the skip list
         skip_children(bi); skip_children(bj)

         # save the similar blocks for post-processing
         similar += [(bi,bj)] if len(bj.code) > len(bi.code) else [(bj,bi)]

      #end

   #end

#end

similar = sorted(similar, key=lambda x: len(x[0].code), reverse=True)

#------------------------------------------------------------------------------
#
#  HTML formatting helpers
#
#------------------------------------------------------------------------------

VSP = '&#9474' # vertical separator
GRN = '<span style="background:#ccffcc">'
RED = '<span style="background:#ffcccc">'
GRY = '<span style="color:#cccccc">'
YEL = '<span style="color:#ffd480">'
ESP = '</span>'

def esc(s): return s.replace('<', '&lt;')

def diff2html(df, bi, bj, index):

    html = ""
    width = args.diff_width
    middle = int(width/2)

    DIV  = GRY + VSP + ESP
    DIV2 = YEL + VSP + ESP
 
    # section links
    html += '<pre style='
    html += '"background:white;caret-color:transparent;'
    html += 'border:none;text-align:center">\n'
    html += '<span '
    html += 'id="%s"' % index
    html += 'style="">'
    if index == 1000:
       html += ' <a href="#%s">next</a>' % (index + 1)
       html += '</span>'
       html += ' ' * (width - 4)
    else:
       html += ' <a href="#%s">next</a>' % (index + 1) 
       html += ' <a href="#%s">prev</a>' % (index - 1)
       html += ' <a href="#%s">up</a>' % (1000)
       html += '</span>'
       html += ' ' * (width - 12)
    #end

    html += '</pre>'

    # section file headers
    html += '<pre style='
    html += '"background:white;caret-color:transparent;'
    html += 'border:none;text-align:center">'
    html += '<span style="border:1px #ccc solid;'
    html += 'border-radius:3px;padding:5px;font-weight:bold">'
    H1 = ' %s:%d' % (bi.file, bi.range[0])
    H2 = ' %s:%d' % (bj.file, bj.range[0])
    html += ( H1 + ' '*((middle-1)-len(H1)))
    html += VSP
    html += ( H2 + ' '*(middle-len(H2)) )
    html += '</span></pre>\n'

    # diff
    html += '<pre style='
    html += '"background:white;caret-color:transparent;'
    html += 'border:none;text-align:center">\n'

    for line in df:

        line = line[:-1]
        line += ' '*(width-len(line))

        dm = line[middle-1]
        L1 = line[:middle-1]
        L2 = line[middle:]

        if dm == ' ':
           L1 = esc(L1); L2 = esc(L2)
           html += "%s%s%s\n" % (L1, DIV, L2)
        else:
           if dm == '|':
              nd = ndiff(L1, L2)
              S1 = ''
              S2 = ''
              for i in nd:
                 ch = esc(i[2])
                 if i[0] == ' ':
                    S1 += ch
                    S2 += ch
                 if i[0] == '+':
                    if ch.isspace():
                       S2 += ch
                    else:
                       S2 += GRN + ch + ESP
                 if i[0] == '-':
                    if ch.isspace():
                       S1 += ch
                    else:
                       S1 += RED + ch + ESP
                 #end
              #end
              html += '%s%s%s\n' % (S1, DIV2, S2)
           else:
              L1 = esc(L1); L2 = esc(L2)
              if dm == '<':
                 html += '%s%s%s%s%s\n' % (RED, L1, ESP, DIV, L2)
              if dm == '>':
                 html += '%s%s%s%s%s\n' % (L1, DIV, GRN, L2, ESP)
           #end

        #end

    #end

    html += '</pre>\n'

    return html

#end

#------------------------------------------------------------------------------
#
#  Post processing
#
#------------------------------------------------------------------------------

print_spinner('post processing')

DN = '2>/dev/null'
root = '/tmp/refactor-%d' % os.getpid()
os.system('mkdir -p %s/diffs' % root)
os.system('mkdir -p %s/files' % root)

def dash(fname): fname.replace('/', '-')

index = 1000

for (bi, bj) in similar:

    fstr = '%s/files/%d-%s-%d-%d'
    farg = (root, index, dash(bi.file), bi.range[0], bi.range[1])
    bifn = fstr % farg
    farg = (root, index, dash(bj.file), bj.range[0], bj.range[1])
    bjfn = fstr % farg
    with open(bifn, 'w') as f: f.write(bi.code)
    with open(bjfn, 'w') as f: f.write(bj.code)

    dif = '%s/diffs/%d.diff' % (root, index)
    cmd = 'diff -t -y --width=%d %s %s > %s'
    cmd = cmd % (args.diff_width, bifn, bjfn, dif)
    os.system(cmd)

    htf = dif.replace('.diff', '.html')
    with open(dif, 'r') as f: html = diff2html(f, bi, bj, index)
    with open(htf, 'w') as f: f.write(html)

    index += 1

#end

print_spinner('', force=1)

nsimilar = len(similar)

print(nsimilar, 'similar blocks found')

if not nsimilar: sys.exit(0)

output = ('refactor-%d.html' % os.getpid())

if args.output: output = args.output

cmd = 'cat %s/diffs/*.html > %s %s ' % (root, output, DN)
os.system(cmd)
print('>', output)

if not args.no_cleanup: os.system('rm -rf %s' % root)


