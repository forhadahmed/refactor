#!/usr/bin/env python3
import io, os, sys, time

# TODO
# - reduce parse errors
# - line number inaccuracy
# - collapsible sections?
# - section links within document
# - section links to source code (external)
# - diff <small> <large> (instead of *)
# - scrolling spinner bug
#

from difflib import SequenceMatcher as SM
from difflib import ndiff as ndiff

#------------------------------------------------------------------------------
#
#  Misc
#
#------------------------------------------------------------------------------

def spinning_cursor():
    while True:
      for cursor in ['[|]','[/]','[-]','[\\]']:
        yield cursor

spinner = spinning_cursor()
mlen = 0
sidx = 0

def print_spinner(f, rate=30000, force=0):
    global mlen,sidx
    sidx += 1
    if not (sidx % rate) or force:
       sys.stdout.write(next(spinner) + ' ' + f)
       sys.stdout.flush()
       sys.stdout.write(' '*(mlen+10) +'\r')
       sys.stdout.flush()

#------------------------------------------------------------------------------

code     = 0 # normal code
macro    = 1 # #define ...
string1  = 2 # "abc"
string2  = 3 # 'd'
comment1 = 4 # // comment
comment2 = 5 # /* comment */

state  = code
indent = 0
stack  = []
blocks = []

class block:
   def __init__(self, file, line, indent, parent):
       self.file = file
       self.range = [line,-1]
       self.indent = indent
       self.parent = parent
       self.code = []
       self.children = []
   #end

   def add_code(self, c):
       self.code += [c]
       if self.parent: self.parent.add_code(c)
   #end
#end


def process(file, ch, line):

    global state, indent, stack, blocks
    top = stack[-1] if stack else None

    # start of block
    if ch == '{' and state == code:
       indent += 1
       b = block(file, line, indent, top)
       if top: top.children.append(b)
       stack.append(b)
       blocks.append(b)
    #end

    # end of block
    if ch == '}' and state == code:
       indent -= 1
       if not stack:
          print('[!]', file) # error
          return False
       b = stack.pop()
       b.range[1] = line

    #end

    print_spinner(file)

    if top: top.add_code(ch)

    return True;

#end

import argparse

parser = argparse.ArgumentParser()
parser.add_argument('--min-block-size', default=1000, type=int)
parser.add_argument('--max-block-diff', default=500, type=int)
parser.add_argument('--similarity', default=0.8, type=float)
parser.add_argument('--diff-width', default=180, type=int)
parser.add_argument('--no-cleanup', action='store_true')
parser.add_argument('--all-levels', action='store_true')
parser.add_argument('--all-files', action='store_true')

args, inputs = parser.parse_known_args()

#------------------------------------------------------------------------------
#
#  Parsing
#
#------------------------------------------------------------------------------

for fn in inputs:

  line = 1
  mlen = max(len(fn), mlen)

  with open(fn) as f:

    ch = 0; pch = 0

    while 1:

      ch = f.read(1)
      if not ch: break

      if ch == '\n': line += 1

      if state == code:
         if ch == '#':
            state = macro
         if ch == '"':
            state = string1
         if ch == "'":
            state = string2
         if ch == '/':
            if not process(fn, ch, line): break
            ch = f.read(1)
            if not ch: break
            if ch == '/':
               state = comment1
            if ch == '*':
               state = comment2

      elif state == string1:
         if ch == '"':
            state = code

      elif state == string2:
         if ch == "'":
            state = code

      elif state == comment1 or state == macro:
         if ch == '\n' and pch != '\\':
            state = code

      elif state == comment2:
         if ch == '*':
            if not process(fn, ch, line): break
            ch = f.read(1)
            if not ch: break
            if ch == '/':
               state = code
      #end

      if not process(fn, ch, line): break

      pch = ch

   #end

  if indent: indent = 0 # warning

#end


#------------------------------------------------------------------------------
#
#  Processing
#
#------------------------------------------------------------------------------

# filter out small blocks
blocks = [ b for b in blocks if len(b.code) > args.min_block_size ]

blocks = sorted(blocks, key=lambda x: len(x.code), reverse=True)

for b in blocks: b.code = ''.join(b.code)

skip = []

def skip_children(b):
    global skip
    for ch in b.children:
      if ch in blocks:
        skip += [blocks.index(ch)]
        skip_children(ch)
    #end
#end

def ancestor(a, b):
    p = a.parent
    while p:
       if b == p: return 1
       p = p.parent
    #end
    return 0
#end

def dash(fname):
    if fname[0] == '/': fname = fname[1:]
    return fname.replace('/', '-')

fcache = {}

# return true to skip block comparison based on filenames
def skip_unrelated_files(f1, f2):
    if args.all_files: return False
    global fcache
    if (f1,f2) in fcache: return fcache[(f1,f2)]
    if (f2,f1) in fcache: return fcache[(f2,f1)]
    if f1 == f2:
       return False
    else:
       if SM(None, f1, f2).ratio() < 0.9:
          fcache[(f1,f2)] = True
          return True
       else:
          fcache[(f1,f2)] = False
          return False
       #end
    #end
#end

root = '/tmp/refactor-%d' % os.getpid()

os.system('mkdir -p %s/diffs' % root)
os.system('mkdir -p %s/files' % root)

index = 1000

L = len(blocks)

for i in range(0, L-1):

   for j in range(i+1, L-1):

      index += 1

      print_spinner('comparing blocks %4d - %4d' % (i,j), rate=200)

      # skip if either block is a child of matched block
      if i in skip or j in skip: continue

      bi = blocks[i]; bj = blocks[j]

      # skip if filenames are unrelated
      if skip_unrelated_files(bi.file, bj.file): continue

      # skip if one block is a parent of another
      if ancestor(bi, bj) or ancestor(bj, bi): continue

      # skip if the length of code sections differs by a threshold
      if abs(len(bi.code)-len(bj.code)) > args.max_block_diff: continue

      # skip if blocks are not on the same level
      if not args.all_levels and bi.indent != bj.indent: continue

      # do the comparison (skip if blocks are not similar)
      sm = SM(None, bi.code, bj.code)
      if sm.quick_ratio() < 0.8: continue
      if sm.ratio() < 0.8: continue

      # found similar blocks - add their children to the skip list
      skip_children(bi); skip_children(bj)

      # save the blocks for post-processing
      fstr = '%s/files/%d-%s-%d-%d'
      bi_args = (root, index, dash(bi.file), bi.range[0], bi.range[1])
      bj_args = (root, index, dash(bj.file), bj.range[0], bj.range[1])
      with open(fstr % bi_args, 'w') as f: f.write(bi.code)
      with open(fstr % bj_args, 'w') as f: f.write(bj.code)

   #end

#end


#------------------------------------------------------------------------------
#
#  Post-processing
#
#------------------------------------------------------------------------------

print_spinner('post processing')

os.system("""
ls -S %s/files/     \
  | cut -d '-' -f1  \
  | uniq | sort     \
  | xargs -n1 -I {} \
    sh -c 'diff -t -y --width=%d %s/files/{}* > %s/diffs/{}.diff'
""" % (root, args.diff_width, root, root))

VSP = '&#9474' # vertical separator
GRN = '<span style="background:#ccffcc">'
RED = '<span style="background:#ffcccc">'
GRY = '<span style="color:#cccccc">'
YEL = '<span style="color:#ffd480">'
ESP = '</span>'

def esc(s): return s.replace('<', '&lt;')

def diff2html(df, F1, R1, F2, R2):

    html = ""
    width = args.diff_width
    middle = int(width/2)

    DIV  = GRY + VSP + ESP
    DIV2 = YEL + VSP + ESP

    html += '<pre style='
    html += '"background:white;'
    html += 'border:none;text-align:center">'
    html += '<span style="border:1px #ccc solid;'
    html += 'border-radius:5px;padding:5px;font-weight:bold">'

    H1 = ' %s (%s)' % (F1, R1)
    H2 = ' %s (%s)' % (F2, R2)

    html += ( H1 + ' '*(middle-len(H1)-1) )
    html += VSP
    html += ( H2 + ' '*(middle-len(H1)) )

    html += '</span></pre>\n'

    html += '<pre style='
    html += '"background:white;'
    html += 'border:none;text-align:center">\n'

    for line in df:

        line = line[:-1]
        line += ' '*(width-len(line))

        dm = line[middle-1]
        L1 = line[:middle-1]
        L2 = line[middle:]

        if dm == ' ':
           L1 = esc(L1); L2 = esc(L2)
           html += "%s%s%s\n" % (L1, DIV, L2)
        else:
           if dm == '|':
              nd = ndiff(L1, L2)
              S1 = ''
              S2 = ''
              for i in nd:
                 ch = esc(i[2])
                 if i[0] == ' ':
                    S1 += ch
                    S2 += ch
                 if i[0] == '+':
                    if ch.isspace():
                       S2 += ch
                    else:
                       S2 += GRN + ch + ESP
                 if i[0] == '-':
                    if ch.isspace():
                       S1 += ch
                    else:
                       S1 += RED + ch + ESP
                 #end
              #end
              html += '%s%s%s\n' % (S1, DIV2, S2)
           else:
              L1 = esc(L1); L2 = esc(L2)
              if dm == '<':
                 html += '%s%s%s%s%s\n' % (RED, L1, ESP, DIV, L2)
              if dm == '>':
                 html += '%s%s%s%s%s\n' % (L1, DIV, GRN, L2, ESP)
           #end

        #end

    #end

    html += '</pre><br>\n'

    return html

#end

import glob

files = glob.glob('%s/files/*' % root)

for file in glob.glob('%s/diffs/*.diff' % root): # sort by size

    tag = file.split('/')[-1].split('.')[0]
    ftag = [ f for f in files if ('files/%s' % tag) in f ]
    ftag = [ f.replace('%s/files/' % root, '') for f in ftag ]
    ftag = [ f.replace('%s-'% tag, '') for f in ftag]

    f = ftag[0]
    d = f[:f.rfind('-')].rfind('-')
    r = f[d+1:]
    f = f[:d]
    f = [ i for i in inputs if dash(i) in f ][0]
    F1 = f; R1 = r

    f = ftag[1]
    d = f[:f.rfind('-')].rfind('-')
    r = f[d+1:]
    f = f[:d]
    f = [ i for i in inputs if dash(i) in f ][0]
    F2 = f; R2 = r

    with open(file, 'r') as f: html = diff2html(f, F1, R1, F2, R2)
    file = file.replace('.diff', '.html')
    with open(file, 'w') as f: f.write(html)

#end


print_spinner('', force=1)

DN = '2>/dev/null'
os.system('echo $(ls %s/d*/*.*ml %s | wc -l) similar' % (root, DN))
os.system('ls -S %s/d*/*.*ml %s | xargs cat > ~/diffs.html ' % (root, DN))

if not args.no_cleanup: os.system('sudo rm -rf %s' % root)


